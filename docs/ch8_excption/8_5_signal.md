# 예외적 제어 흐름(ECF)과 시그널 완전 정복

## 예외상황(Exception)의 기본 개념

### 예외상황이란?

- 하드웨어와 소프트웨어가 협력하여 구현하는 예외적 제어 흐름의 한 형태
- 프로세서 상태의 급작스러운 변화에 대응하여 제어 흐름을 갑자기 바꾸는 메커니즘
- 점프 테이블(예외 테이블)을 이용해 미리 짜둔 예외 처리 핸들러로 간접 프로시저 콜 수행

### ECF의 다양한 형태들

**하드웨어 레벨:**

- 예외(Exceptions) - 하드웨어가 감지한 이벤트로 인한 급작스러운 제어 흐름 변화

**운영체제 레벨:**

- 컨텍스트 스위치(Context Switch) - 커널이 프로세스 간 전환을 통한 제어 흐름 변화
- 프로세스 스케줄링 - 시분할을 통한 멀티태스킹

**애플리케이션 레벨:**

- 시그널(Signals) - 프로세스 간 통신을 통한 제어 흐름 변화
- 비지역 점프(Nonlocal Jumps) - setjmp/longjmp, C++/Java의 try/catch/throw

## 예외상황과 프로시저 콜의 차이점

### 공통점

- 둘 다 다른 코드 위치로 제어 흐름 전달
- 스택을 사용한 상태 관리
- 나중에 원래 위치로 복귀 가능성

### 핵심 차이점

**리턴 주소:**

- 프로시저 콜: 항상 다음 명령어로 명확한 리턴
- 예외상황: 예외 종류에 따라 현재/다음/종료로 다양

**스택 사용:**

- 프로시저 콜: 사용자 스택만 사용
- 예외상황: 커널 스택으로 전환

**저장되는 정보:**

- 프로시저 콜: 리턴 주소만 저장
- 예외상황: 리턴 주소 + EFLAGS 레지스터 + 범용 레지스터들

**실행 모드:**

- 프로시저 콜: 동일한 권한 레벨 유지
- 예외상황: 사용자 모드 → 커널 모드 전환

## EFLAGS 레지스터와 상태 보존

### EFLAGS 레지스터 구성

- **CF(Carry Flag)**: 부호 없는 오버플로우 검출
- **ZF(Zero Flag)**: 연산 결과가 0인지 표시
- **SF(Sign Flag)**: 연산 결과가 음수인지 표시
- **OF(Overflow Flag)**: 부호 있는 오버플로우 검출

### 예외 발생시 상태 보존 과정

```
사용자 모드 실행 중 → 예외 발생
↓
1. 커널 스택으로 전환
2. EFLAGS 레지스터를 커널 스택에 push
3. 리턴 주소를 커널 스택에 push
4. 범용 레지스터들 저장
5. 커널 모드로 전환
6. 모든 시스템 자원 접근 가능
```

### 복구 과정

```
예외 처리 완료 후
↓
1. 특별한 "return from interrupt" 명령어 실행
2. 커널 스택에서 EFLAGS 레지스터 복원
3. 커널 스택에서 리턴 주소 복원
4. 범용 레지스터들 복원
5. 사용자 모드로 전환
6. 원래 프로그램 실행 재개
```

## 4가지 예외 클래스

### 인터럽트 (Interrupt) - 비동기

**특징:**

- I/O 디바이스의 시그널로 발생
- 현재 실행 중인 명령어와 무관
- 항상 다음 명령어로 리턴

**실제 예시:**

- 타이머 인터럽트 (1ms마다 스케줄링)
- 키보드 입력 (사용자가 키 누름)
- 네트워크 패킷 도착
- 디스크 I/O 완료 알림

### 트랩 (Trap) - 동기

**특징:**

- 의도적인 예외 (syscall 명령어 등)
- 시스템 콜을 통한 커널 서비스 요청
- 항상 다음 명령어로 리턴

**실제 예시:**

- `syscall` 명령어 실행
- `read()`, `write()`, `fork()` 시스템 콜
- `int 0x80` (구버전 리눅스)

### 폴트 (Fault) - 동기, 복구 가능

**특징:**

- 핸들러가 오류를 정정할 수 있는 경우
- 정정 성공시 현재 명령어 재실행
- 정정 실패시 프로그램 종료

**실제 예시:**

- 페이지 폴트 (메모리 페이지 부재)
- 정렬 오류 (잘못된 메모리 정렬)
- 0으로 나누기 오류

### 중단 (Abort) - 동기, 복구 불가능

**특징:**

- 치명적인 하드웨어 오류
- 절대 원래 프로그램으로 복귀하지 않음
- 프로그램 강제 종료

**실제 예시:**

- 메모리 패리티 에러
- DRAM/SRAM 비트 손상
- 치명적인 하드웨어 장애

## 시그널(Signal) - 상위 수준 소프트웨어 ECF

### 시그널의 정의와 역할

- 프로세스와 커널이 다른 프로세스를 중단시킬 수 있는 상위 수준 소프트웨어의 ECF
- 하위 수준 하드웨어 예외는 커널이 은밀하게 처리 (사용자 모름)
- 시그널은 사용자 프로세스에게 이벤트를 알리는 메시지 메커니즘

### 시그널의 두 가지 동작

**시그널 보내기 (Sending):**

1. **시스템 이벤트 감지**: 커널이 하드웨어 예외를 시그널로 변환
2. **명시적 전송**: 프로세스가 다른 프로세스에게 직접 전송

**시그널 받기 (Receiving):**

- 프로세스가 커널 모드에서 사용자 모드로 전환할 때 체크
- 블록되지 않은 펜딩 시그널 확인 후 처리

## 프로세스 그룹과 시그널 전송

### 프로세스 그룹 메커니즘

- 연관된 프로세스들을 그룹으로 묶어서 관리
- 포그라운드 프로세스 그룹: 터미널의 Ctrl+C, Ctrl+Z 신호 수신
- 백그라운드 프로세스 그룹: 터미널 신호 무시
- 쉘이 job 단위로 프로세스 그룹 관리

### 시그널 전송 방법

**1. /bin/kill 프로그램:**

```bash
/bin/kill -9 1234        # PID 1234에 SIGKILL 전송
/bin/kill -TERM -5678    # 프로세스 그룹 5678에 SIGTERM 전송
```

**2. 키보드 입력:**

- Ctrl+C: 포그라운드 프로세스 그룹에 SIGINT 전송
- Ctrl+Z: 포그라운드 프로세스 그룹에 SIGTSTP 전송

**3. kill() 함수:**

```c
kill(pid, SIGTERM);      # 특정 프로세스에 전송
kill(0, SIGUSR1);        # 현재 프로세스 그룹에 전송
kill(-pgid, SIGKILL);    # 특정 프로세스 그룹에 전송
```

## 펜딩 시그널의 특별한 특성

### 비트벡터 기반 관리

```
펜딩 시그널 비트벡터:
[SIGHUP][SIGINT][SIGQUIT]...[SIGUSR1][SIGUSR2]...
   0       1        0            0        1
```

### 핵심 제약사항

- **각 시그널 타입당 최대 1개만 펜딩 가능**
- 같은 타입의 시그널이 여러 번 와도 하나로 합쳐짐
- 정확한 발생 횟수는 알 수 없고, "최소 1번 발생했다"는 사실만 확인 가능

### 실제 문제 사례

```c
// 3개 자식 프로세스가 동시에 종료
child1: exit(0);  // SIGCHLD 전송 → 펜딩 비트 1
child2: exit(0);  // SIGCHLD 전송 → 버려짐 (이미 1)
child3: exit(0);  // SIGCHLD 전송 → 버려짐 (이미 1)

// 결과: 부모는 SIGCHLD를 1번만 받음 → 2개 자식이 좀비로 남음!
```

## 시그널 대기 vs 소멸의 차이

### 대기 (Pending) 상태

```c
signal(SIGINT, handler);
sigset_t mask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);
sigprocmask(SIG_BLOCK, &mask, NULL);  // SIGINT 블록

// 이 상태에서 SIGINT 발생 → 펜딩 상태로 대기
// 나중에 언블록하면 처리됨
sigprocmask(SIG_UNBLOCK, &mask, NULL);  // 이때 처리!
```

### 소멸 (Discarded) 상태

```c
// SIGINT가 이미 펜딩 상태일 때
kill(pid, SIGINT);  // 첫 번째 → 펜딩 비트 설정
kill(pid, SIGINT);  // 두 번째 → 영원히 소멸!
kill(pid, SIGINT);  // 세 번째 → 영원히 소멸!
```

**핵심 차이:**

- **대기**: 블록되어 있어서 나중에 처리될 예정 (복구 가능)
- **소멸**: 영원히 사라짐, 절대 복구 불가능

## 시그널 커스터마이징과 제약사항

### signal() 함수를 통한 커스터마이징

```c
signal(SIGINT, my_handler);     // 사용자 정의 핸들러
signal(SIGTERM, SIG_IGN);       // 시그널 무시
signal(SIGUSR1, SIG_DFL);       // 기본 동작으로 복원
```

### 변경 불가능한 시그널

- **SIGSTOP**: 프로세스 정지 (변경 불가)
- **SIGKILL**: 프로세스 강제 종료 (변경 불가)

### 시그널 핸들러 작성시 주의사항

**안전성 문제:**

- `async-signal-safe` 함수만 사용 가능
- 전역 변수는 `volatile` 키워드로 선언
- `errno` 값을 저장/복원해야 함

**동시성 문제:**

- 메인 프로그램과 핸들러가 메모리 공유
- Race condition 발생 가능
- 시그널 수신 타이밍이 비예측적

**이식성 문제:**

- 시스템마다 시그널 처리 방식이 다름
- POSIX 표준 준수 함수 사용 권장
- `sigaction()` 함수가 `signal()`보다 안전

## 시그널 블록킹 메커니즘

### 기본 블록킹

- 시그널 핸들러 실행 중에는 같은 타입의 시그널 자동 블록
- 핸들러 완료 후 자동 언블록

### 명시적 블록킹

```c
sigset_t mask, oldmask;
sigemptyset(&mask);
sigaddset(&mask, SIGCHLD);
sigprocmask(SIG_BLOCK, &mask, &oldmask);    // 블록
// 중요한 코드 실행...
sigprocmask(SIG_SETMASK, &oldmask, NULL);   // 복원
```

이처럼 예외적 제어 흐름과 시그널은 현대 운영체제의 핵심 메커니즘이며, 시스템 프로그래밍에서 반드시 이해해야 할 중요한 개념들이다.