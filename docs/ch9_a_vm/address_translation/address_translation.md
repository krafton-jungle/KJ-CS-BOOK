# 주소 변환 (가상 → 물리)

## 이 장에서 다루는 내용

이 문서는 프로세스의 가상 주소를 물리 주소로 바꾸는 **주소 변환(Address Translation)**의 핵심 흐름을 간단히 정리한다.

- [간단한 설명] TLB, 페이지 테이블, 페이지 폴트의 역할과 순서를 파악한다.
- [학습 이유] 성능과 보호 측면에서 가상 메모리가 왜 필요한지, 코드가 메모리에 접근할 때 실제로 어떤 일이 일어나는지 이해한다.

## 주요 키워드

| 키워드        | 키워드        | 키워드      |
| ------------- | ------------- | ----------- |
| 가상 주소(VA) | 물리 주소(PA) | 페이지 크기 |
| 페이지 번호   | 페이지 오프셋 | 프레임 번호 |
| TLB           | 페이지 테이블 | 페이지 폴트 |

## 1. 주소 변환이란?

각 프로세스는 자신만의 연속된 메모리를 보는 것처럼 동작하지만, 실제 물리 메모리는 여러 프로세스가 **페이지 단위**로 공유한다.  
CPU가 생성한 **가상 주소(VA)**는 MMU가 **TLB와 페이지 테이블**을 이용해 **물리 주소(PA)**로 변환한다.  
필요 시 운영체제가 개입해 디스크에서 페이지를 적재하거나 보호 위반을 처리한다.

## 2. 주소 형식

가상/물리 주소는 페이지 크기에 따라 상위 비트(페이지 번호)와 하위 비트(오프셋)로 나뉜다.

```
VA: [   VPN   |   VPO ]    // 가상 페이지 번호, 가상 페이지 오프셋
PA: [   PPN   |   PPO ]    // 물리 프레임 번호, 물리 페이지 오프셋(=VPO)
```

- 예) 페이지 크기 4KB → 오프셋 12비트. 상위 비트(VPN)는 페이지를, 하위 12비트(VPO)는 페이지 내부 바이트 위치를 뜻한다.
- 변환의 본질: `VPN → PPN` 매핑을 찾고, 기존 오프셋을 그대로 붙여서 PA를 만든다.

> 💡 오프셋 비트 수는 VA와 PA에서 동일하다. 페이지 크기가 같기 때문에 페이지 내부 위치는 변환되지 않는다.

## 3. 변환 단계 (간단)

1. 가상 주소 분해  
   VA를 `VPN`과 `VPO`로 나눈다.

2. TLB 조회  
   TLB에 `VPN → PPN` 항목이 있으면(히트) 즉시 `PPN`을 얻는다.

3. 페이지 테이블 탐색  
   TLB 미스면 페이지 테이블(보통 다단계)을 따라 `VPN → PPN`을 찾는다.  
   항목이 유효하면 TLB에 적재하고 다음 단계로 진행한다.

4. 페이지 폴트 처리  
   항목이 없거나 접근 권한이 없다면 폴트가 발생한다. OS가 페이지를 메모리로 적재하거나 접근 위반을 신호한다.

5. 물리 주소 구성  
   `PA = [PPN | VPO]`로 조합한다. 오프셋(VPO)은 그대로 유지된다.

6. 메모리 접근  
   캐시/메모리에서 데이터를 읽거나 쓴다. 필요 시 TLB가 갱신된다.

## 4. 간단한 그림

```
      VA
 [   VPN   |   VPO ]
      │          │
      │          └─ 그대로 유지
      ▼
   TLB / PT   ⇒   PPN
      │
      ▼
 [   PPN   |   PPO ]
            (PPO=VPO)
      PA
```

> 💡 보호 비트(읽기/쓰기/실행)는 변환 과정에서 함께 검사된다. 위반 시 예외가 발생한다.

## 마무리

주소 변환은 `VPN → PPN`을 찾고 기존 오프셋을 붙여 **PA를 구성**하는 과정이다.  
TLB가 빠른 변환을, 페이지 테이블과 운영체제가 **정확성과 보호**를 보장한다.
