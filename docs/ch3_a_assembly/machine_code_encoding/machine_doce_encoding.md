# 3. 프로그램의 기계수준 표현

컴퓨터는 하위 동작들을 인코딩한 연속된 바이트인 **기계어 코드(machine code)** 를 실행한다.  
**컴파일러**는 프로그래밍 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 **기계어 코드를 생성**한다.

GCC C 컴파일러는 기계어 코드를 문자로 표시한 어셈블리 코드의 형태로 출력을 만들어  
프로그램의 각 인스트럭션을 만든다.  
GCC는 어셈블러와 링커를 호출하여 어셈블리 코드로부터 실행 가능한 기계어 코드를 생성한다.

C 같은 고급 언어로 프로그램할 때, 작성한 프로그램이 기계어 수준에서 어떻게 구현되어 있는지  
**자세한 내용은 드러나지 않는다.**  
어셈블리 코드로 프로그램을 짤 때는 프로그래머가 계산을 하기 위해 사용해야 하는  
**저급 인스트럭션들을 명시**해야 한다.

고급 언어가 제공하는 추상화를 사용하는 것이 더 **생산적이고 안정적**이다.  
컴파일러에서 제공하는 **타입 체크 기능은** 프로그램 **에러를 검출하는 데 도움**을 주고,  
**데이터를 균일하게 참조하고 처리하는 일을 정확히 알 수 있도록** 도와준다.  
현대 컴파일러가 만든 코드는 **효율적인 코드를 생성**하고  
다른 컴퓨터에서 컴파일과 실행이 가능하다.

반면, **어셈블리 코드**는 **컴퓨터 기계에 매우 의존적**이다.

---

## 기계어 코드를 배워야 하는 이유

컴파일러가 생성한 머신 코드나 어셈블리 코드를 읽고 분석하여  
**성능, 오류, 보안, 병렬 처리 문제**를 이해하고 해결하는 능력을 갖춰야 한다.

---

## Reverse Engineering (역 엔지니어링)

**역엔지니어링**은 만들어진 과정을 시스템을 연구하고  
**역방향으로 분석하고 이해하는 작업**이다.

---

> 💡 이 책의 어셈블리 언어는 **x86-64 기반**이다.  

# 3.2 프로그램의 인코딩

`gcc -Og` 옵션은 원본 C 코드 구조를 유지하며 적당한 최적화를 수행해  
기계어와 소스코드 관계를 이해하기 쉽게 해주며 학습에 적합하다.  
그러나 실제로는 성능 향상을 위해 `-O1`, `-O2` 같은 **더 높은 최적화 옵션**을 주로 사용한다.

> 최적화 수준을 올리면 성능은 향상되지만  
> 컴파일 시간이 늘어나고, 디버깅이 어려워지며  
> 코드와 생성된 기계어 코드의 대응이 불명확해진다.

---

## 컴파일 과정

`gcc` 명령은 소스 코드를 실행 코드로 변환하기 위해 여러 단계를 거친다:

1. **전처리기**  
   `#include`로 명시된 파일을 코드에 삽입하고,  
   `#define`으로 선언된 매크로를 확장함.

2. **컴파일러**  
   소스 파일의 어셈블리 코드 버전 (`p1.s`, `p2.s`) 생성.

3. **어셈블러**  
   어셈블리 코드를 바이너리 목적 코드 (`p1.o`, `p2.o`)로 변환.

4. **링커**  
   두 목적 파일과 라이브러리 함수들을 하나의 실행 파일(`p`)로 결합.

---

## 3.2.1 기계수준 코드

컴퓨터 시스템은 **단순한 추상화 모델**을 통해 내부 세부 사항을 감춘다.  
이러한 추상화 중 핵심은 **ISA (Instruction Set Architecture)** 이다.

### ISA (인스트럭션 집합 구조)

- **기계수준 프로그램의 형식과 동작을 정의**한다.
- 프로세서 상태, 인스트럭션 형식, 상태 변화 등을 규정.
- 프로그램을 **순차적으로 실행되는 것처럼 보이게 한다.**

### 주소 모델

- **기계어 프로그램은 가상 주소**를 사용한다.
- 메모리를 **큰 바이트 배열**처럼 보는 **가상 메모리 모델** 제공.

---

### 주요 구성 요소

- **프로그램 카운터 (PC)**  
  다음 실행할 인스트럭션의 메모리 주소를 가리킨다.

- **정수 레지스터 파일**  
  64비트 값을 저장하는 **이름 붙은 16개 위치**  
  - 주소 계산, 정수 데이터 저장, 상태 추적, 함수 인자/리턴값 등 저장.

- **조건 코드 레지스터**  
  최근 산술/논리 인스트럭션의 상태 정보 저장.  
  - `if`, `while` 제어 흐름 구현 시 사용.

- **벡터 레지스터**  
  여러 개의 정수/부동소수점 값을 저장할 수 있음.

---

### 메모리 모델

- C 언어는 다양한 데이터 타입을 선언하고 메모리에 할당하는 **모델을 제공**.
- 반면, 기계어는 메모리를 단순히 **바이트 주소가 가능한 큰 배열**로 본다.

#### 프로그램 메모리에는 다음이 포함된다:

- 실행할 기계어 코드
- 운영체제 정보
- **런타임 스택** (프로시저 호출/리턴 관리)
- **사용자 동적 메모리 블록**

> 운영체제는 가상주소를 **물리적 주소로 변환**하는 역할을 한다.

---

## 3.2.2 코드 예제

### 목적 코드

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```
위의 사진은 나열된 어셈블리 인스트럭션에 대응되는 **목적 코드**이다.  
중요한 점은 컴퓨터에 의해 실제 실행된 프로그램은 **단순히 일련의 바이트로 인코딩된 인스트럭션**이며,  
**컴퓨터는 이 인스트럭션들이 어떤 소스 코드로부터 생성되었는지 거의 알지 못한다.**


```
1		0000000000000000 <multstore>:
2	     0: 53                 push %rbx
2	     1: 48 89 d3           mov %rdx, %rbx
3	     4: e8 00 00 00 00     callq 9 <multstore+0x9>
4	     9: 48 89 03           mov %rax, (%rbx)
5	     c: 5b                 pop %rbx
6	     d: c3                 retq
```

### 기계어 코드의 특징과 역어셈블 표현

1. **x86-64 인스트럭션**은 **1~15 바이트** 길이를 갖는다.
2. 인스트럭션의 형식은 주어진 시작 위치에서부터 바이트들을  
   **기계어 인스트럭션으로 유일하게 디코딩**할 수 있도록 설계된다.
3. **역어셈블러**는 **기계어 코드의 바이트 순서만을 기반으로** 
   어셈블리 코드를 생성한다.
4. 역어셈블된 코드는 **GCC가 생성한 어셈블리 코드와는** 
   약간 **다른 명명법**을 사용하기도 한다.
   

```
1		0000000000400540 <multstore>:
2	     400540: 53                 push %rbx
2	     400541: 48 89 d3           mov %rdx, %rbx
3	     400544: e8 00 00 00 00     callq 9 <multstore+0x9>
4	     400549: 48 89 03           mov %rax, (%rbx)
5	     40054c: 5b                 pop %rbx
6	     40054d: c3                 retq
7	     40054e
8	     400540
9	     400540
```
### 링커 처리 결과 및 주소 변화

이 코드는 `mstore.c`를 역어셈블한 결과와 **거의 동일**하지만  
왼쪽에 나타나는 **주소가 다르다.**

#### 이유:

1. **링커가 코드 위치를 다른 주소 영역으로 이동**시켰다.
2. **링커가 `callq` 인스트럭션에서 호출할 함수(mult2)의 실제 주소를 채움.**
3. **8번, 9번 줄과 같은 추가된 라인**을 확인할 수 있다.

---

### 링커의 역할

> 링커의 주요 임무는  
> **함수들의 실행 코드 위치와 함수 호출을 일치시키는 것.**

8번, 9번 줄의 인스트럭션은  
7번 줄의 `retq` 인스트럭션 **이후에 실행되므로 프로그램에 아무런 효과가 없다.**

해당 코드는 함수의 길이를 **16바이트로 정렬(padding)**하기 위해 삽입된 것으로,  
이러한 정렬은 **메모리 시스템의 성능 향상**을 돕기 위한 것이다.

