## 3.5 산술연산과 논리연산

x86-64 정수 및 논리 연산의 리스트이다.  
오퍼랜드의 길이에 따라 다양한 변형이 가능하므로, 대부분의 연산은 **인스트럭션 클래스별로 나열**되어 있다.

- 예: 인스트럭션 클래스 `ADD`  
  - `addb` (1바이트)  
  - `addw` (2바이트)  
  - `addl` (4바이트)  
  - `addq` (8바이트)

### 연산 종류
1. 유효주소 적재
2. 단항
3. 이항
4. 쉬프트

- **이항 연산**: 두 개의 오퍼랜드 사용  
- **단항 연산**: 한 개의 오퍼랜드 사용

---

### 3.5.1 유효주소 적재

`leaq`는 `movq`의 변형이며, 메모리 참조 형식을 갖지만 **메모리 참조는 하지 않는다.**

- 첫 번째 오퍼랜드는 메모리 참조처럼 보이지만, **읽지 않고 주소값만 계산**하여 목적지에 복사
- **포인터 생성 또는 간단한 산술 표현**에 유용
- **목적 오퍼랜드는 반드시 레지스터여야 한다**
- 실제 주소 계산과 무관한 경우에도 컴파일러는 자주 사용

---

### 3.5.2 단항 및 이항 연산

#### 단항 연산

- 오퍼랜드가 **소스와 목적지로 동시에 사용**
- 오퍼랜드는 **레지스터 또는 메모리**일 수 있음
- C의 `++`, `--` 연산자와 유사

#### 이항 연산

- 두 오퍼랜드 모두 사용: **소스 → 목적지**
- C의 `x -= y`와 유사 (하지만 **순서 중요**)
- 첫 번째: 상수, 레지스터, 메모리 가능  
  두 번째: **레지스터 또는 메모리 (단, 둘 다 메모리는 불가)**
- 메모리를 목적지로 사용하는 경우, **읽고 연산한 결과를 다시 메모리에 저장**

---

### 3.5.3 쉬프트 연산

- **형식**: 쉬프트 양(먼저), 쉬프트 대상(나중)
- 산술 및 논리 우측 쉬프트 모두 가능
- 쉬프트 양은 **즉시 값** 또는 **레지스터 `%cl`** 사용 가능
- 1바이트 양: 최대 255 (2⁸ - 1)

#### 쉬프트와 비트 수의 관계

- x86-64에서는 **w비트 값 → m비트 쉬프트 양**  
  - `2^m = w` 관계 성립

#### 쉬프트 명령어

- **좌측 쉬프트**: `SAL`, `SHL` (같은 의미, 우측에서 0으로 채움)
- **우측 쉬프트**:  
  - `SHR`: 논리 쉬프트 (0으로 채움)  
  - `SAR`: 산술 쉬프트 (부호 비트 복사)

- 목적 오퍼랜드: **레지스터 또는 메모리**

---

### 3.5.4 토의

- 대부분의 인스트럭션은 **부호/비부호 상관없이 사용 가능**
- **오직 우측 쉬프트만 부호형/비부호형 구분 필요**
- 이는 **2의 보수 산술연산**이 선호되는 이유

#### 컴파일러 활용

- 레지스터는 다양한 값들을 저장하기 위해 재사용됨
- 레지스터 간 데이터 이동은 프로그램 내 연산 최적화의 핵심

---

### 3.5.5 특수 산술연산

- **64비트 × 64비트 = 128비트** 결과  
- x86-64는 128비트 연산에 대해 **제한적 지원** 제공

#### 인텔의 명명 방식

- 워드 (1B), 더블워드 (2B), 쿼드워드 (8B), **옥트워드(oct word, 16B)**

---

#### IMUL (부호 있는 곱셈)

- **IMUL 인스트럭션 클래스**  
  - **2 오퍼랜드 형식**: 64비트 × 64비트 → 64비트 결과  
  - **1 오퍼랜드 형식**: 64비트 × 64비트 → 128비트 결과
    - `%rax` × src → 결과: `%rdx` (상위), `%rax` (하위)

> `imulq`는 여러 형식으로 사용되며, **오퍼랜드 수에 따라 해석됨**

---


- 곱셈 전 **`movq` 두 번 수행** 필요
- 리틀 엔디안 구조에서는 **상위 바이트가 더 높은 주소에 저장**

---

#### 나눗셈 및 나머지 연산

- **IDIVQ** (부호형 나눗셈 인스트럭션)
  - **피제수**: `%rdx`(상위) + `%rax`(하위) = 128비트
  - **제수**: 소스 오퍼랜드
  - **몫**: `%rax`, **나머지**: `%rdx`

#### 64비트 피제수 사용 시

- `%rax`에 값 저장
- `%rdx`는  
  - **비부호형**: 0  
  - **부호형**: `%rax`의 부호 비트를 채움 (cqto 인스트럭션 사용)

```nasm
cqto  ; RAX의 부호 비트를 RDX에 확장 (sign extension)
