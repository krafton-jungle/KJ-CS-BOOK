# 스택(Stack) 데이터의 저장과 추출 (push, pop)


## 이 장에서 다루는 내용

> 프로그램 실행 중 데이터를 임시로 저장하거나 꺼내는 데 사용되는 **스택(Stack)** 자료구조의 동작 방식을 이해한다.
> 
- 스택은 **후입선출(Last-In, First-Out, LIFO)** 원칙으로 데이터를 관리하며, 함수 호출과 반환 등에서 중요한 역할을 한다.
- 스택의 구조와 동작을 이해하면 함수 호출 간 상태를 안전하게 관리하고, 저수준 시스템 코드의 디버깅 및 최적화에 활용할 수 있다.

## 주요 키워드
| 키워드 | 설명 |
| --- | --- |
| 스택(Stack) | 데이터를 임시로 저장하고 꺼내는 LIFO 자료구조 |
| LIFO | Last-In, First-Out, 마지막에 넣은 데이터를 먼저 꺼내는 방식 |
| 스택 포인터(`%rsp`) | 스택의 top 위치를 가리키는 레지스터 |
| `pushq` | 데이터를 스택에 저장하는 명령어 |
| `popq` | 스택에서 데이터를 꺼내오는 명령어 |


## 1. 스택이란?

스택은 프로그램의 실행 중 데이터를 임시로 저장하거나 꺼내는 데 사용하는 자료구조로, 특히 함수 호출과 반환 과정에서 중요한 역할을 한다. 

스택의 가장 큰 특징은 후입선출(Last-In, First-Out, LIFO) 원칙을 따른다는 점이다. 즉, 마지막에 저장한 데이터를 가장 먼저 꺼내는 방식으로 동작한다. 이 특성 덕분에 함수 호출 중에 저장한 데이터를 다시 복원하거나, 함수 호출 간의 상태를 안전하게 관리할 수 있다.

 스택의 이러한 기본 동작은 두 가지 주요 명령어인 `push`와 `pop`을 통해 구현된다.


## 2. 스택의 성장 방향

x86-64 아키텍처에서 스택은 **높은 주소에서 낮은 주소로 성장**한다.

이는 프로그램의 메모리 공간 배치 방식을 고려한 설계로, 코드와 전역 변수, 힙은 낮은 주소에서 높은 주소로 확장되며, 스택은 그 반대 방향인 높은 주소에서 낮은 주소로 확장된다. 이렇게 방향을 분리함으로써 힙과 스택이 충돌하는 것을 방지하고, 각 메모리 영역을 효율적으로 관리할 수 있다. 

따라서:

- 스택에 새로운 데이터를 **추가(push)** 하면 `%rsp`는 감소
- 스택에서 데이터를 **제거(pop)** 하면 `%rsp`는 증가

이러한 동작은 처음에는 직관적이지 않게 느껴질 수 있으나, 메모리의 주소 체계와 스택의 설계 목적을 이해하면 그 이유를 쉽게 이해할 수 있다.


## 3. 스택 연산 과정

### (1) `pushq` 명령어

`pushq`는 데이터를 스택 top에 저장하는  명령어로, 하나의 피연산자를 가진다. 이 피연산자는 스택에 저장할 데이터의 원천(소스)이며, `pushq` 명령어를 실행하면 해당 데이터를 스택의 가장 위(top)에 추가한다. 

동작 과정은:

1. 스택 포인터 `%rsp`의 값을 8만큼 감소시켜 새로운 스택 top의 위치를 만든다.
2. 감소된 `%rsp`가 가리키는 메모리 위치에 지정된 데이터를 저장한다.

따라서 `pushq %rbp`라는 명령어는 다음과 동일한 동작을 수행한다.

예:

```
pushq %rbp
```

이는 아래 명령어와 동일하다.

```
subq $8, %rsp     # 스택 포인터를 8만큼 감소
movq %rbp, (%rsp) # %rbp의 값을 스택 top에 저장
```

> 이러한 방식 덕분에 `pushq` 명령어는 단일 명령어로 처리되며, 코드 크기를 줄이는 효과를 가진다. 
실제로 `pushq`는 기계어 수준에서 단 하나의 opcode로 표현되며, 코드 크기는 1바이트(opcode)로 매우 작다. 반면, 위의 `subq`와 `movq` 두 개의 명령어를 조합하면 총 8바이트의 코드 크기를 차지하게 된다.
> 

---

### (2) `popq` 명령어

`popq` 명령어는 스택에서 데이터를 꺼내 레지스터에 저장하는 역할을 한다. 이 명령어 역시 단일 피연산자를 가지며, 이 피연산자는 데이터를 저장할 목적지(destination)이다.
`popq`의 동작은 두 단계로 이루어진다. 

1. 현재 `%rsp`가 가리키는 메모리 위치(즉, 스택의 top 위치)에서 데이터를 읽어와 목적지 레지스터에 복사한다.
2. `%rsp`를 8만큼 증가시켜 이전 스택 top 위치를 해제한다.

예:

```
popq %rax
```

이는 아래 명령어와 동일하다.

```
movq (%rsp), %rax  # 스택 top의 값을 %rax로 읽어옴
addq $8, %rsp      # 스택 포인터를 8만큼 증가
```


## 4. 예제 코드

이러한 스택의 동작 방식을 보다 명확하게 이해하기 위해 간단한 어셈블리 코드 예제를 살펴보겠다.

```
movq $0x123, %rax    # %rax에 0x123 저장
movq $0x456, %rbx    # %rbx에 0x456 저장
pushq %rax           # %rax를 스택에 저장
pushq %rbx           # %rbx를 스택에 저장
popq %rcx            # 스택에서 꺼내 %rcx에 저장
popq %rdx            # 스택에서 꺼내 %rdx에 저장
```

이 코드에서 먼저 `%rax`와 `%rbx`에 각각 `0x123`과 `0x456` 값을 저장한다.  실행 전 스택 포인터 `%rsp`의 초기 값은 `0x108`으로 가정한다. 이후 `pushq` 명령어를 통해 이 값들을 스택에 차례로 저장한다.  `pushq %rax`를 실행하면, 스택 포인터 `%rsp`는 8만큼 감소하여 `0x100`이 되고,  그 위치(0x100)에 `%rax`의 값 `0x123`이 저장된다.  이어 `pushq %rbx`를 실행하면, `%rsp`는 다시 8만큼 감소하여 `0xF8`이 되고, 그 위치(0xF8)에 `%rbx`의 값 `0x456`이 저장된다.

`popq` 명령어는 스택에 저장된 값을 꺼내어 레지스터에 복사하며,  먼저 `popq %rcx`를 실행하면, `%rsp`가 가리키는 위치(0xF8)의 값 `0x456`이 `%rcx`로 복사되고,  그 후 `%rsp`는 8만큼 증가하여 `0x100`이 된다.  마지막으로 `popq %rdx`를 실행하면, `%rsp`가 가리키는 위치(0x100)의 값 `0x123`이 `%rdx`로 복사되며,  `%rsp`는 다시 8만큼 증가하여 원래 위치인 `0x108`으로 돌아간다.

### 스택 포인터와 메모리 상태 변화 예시

| 명령어 | `%rsp` 값 | 메모리 변화 (주소: 값) | 레지스터 상태 |
| --- | --- | --- | --- |
| 초기 상태 | 0x108 |  | `%rax`=0x123, `%rbx`=0x456 |
| `pushq %rax` | 0x100 | 0x100: 0x123 |  |
| `pushq %rbx` | 0xF8 | 0xF8: 0x456, 0x100: 0x123 |  |
| `popq %rcx` | 0x100 | 0xF8: (0x456 남아있음), 0x100:0x123 | `%rcx`=0x456 |
| `popq %rdx` | 0x108 | (값은 남아있음) | `%rdx`=0x123 |

---

## 5. 보충 설명

> 스택의 메모리 방향성과 연산 원리는 처음엔 직관적이지 않을 수 있지만, 메모리 구조와 운영체제 설계를 이해하면 합리적임을 알 수 있다.
> 
> 
> 힙과 스택의 충돌을 방지하기 위해 서로 반대 방향으로 확장되도록 설계되어 있으며, 이 설계 덕분에 안전하고 효율적인 메모리 관리를 가능하게 한다.
>