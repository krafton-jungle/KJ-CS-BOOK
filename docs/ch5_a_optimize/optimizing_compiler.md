# 이 장에서 다루는 내용

* **간단한 설명**: 프로그램 최적화 기법의 주요 개념을 이해한다.
* **학습 이유**: 컴파일러와 시스템 수준에서 성능 저해 요소를 제거하여 효율적인 코드를 작성할 수 있다.

# 주요 키워드

| 키워드                                | 키워드                              |
| ---------------------------------- | -------------------------------- |
| [최적화 컴파일러](#1-최적화-컴파일러의-능력과-한계-51) | [프로그램 성능 표현](#2-프로그램-성능-표현-52)   |
| [프로그램 예시](#3-프로그램-예시-53)           | [반복문 비효율성 제거](#4-반복문-비효율성-제거-54) |
| [프로시저 호출 감소](#5-프로시저-호출-감소-55)     | `CPE`                            |

# 1. 최적화 컴파일러의 능력과 한계

컴파일러는 다양한 최적화를 수행하여 프로그램 성능을 향상시킬 수 있다.
하지만 부작용(side effects)이 있는 함수 호출이나 메모리 별칭(memory aliasing)이 발생할 수 있는 경우처럼 프로그램의 정확한 동작을 변경할 수 있는 최적화는 수행하지 않는다.
이는 컴파일러가 모든 가능한 실행 시나리오를 예측하기 어렵기 때문이다.
따라서 일부 최적화는 프로그래머가 수동으로 수행해야 한다.

# 2. 프로그램 성능 표현

성능 개선은 일반적으로 Told/Tnew(원래 시간 대비 수정된 시간) 비율로 표현하는 것이 바람직하다.
Amdahl의 법칙은 시스템의 한 부분(α)을 k배 빠르게 만들었을 때 전체 시스템의 최대 속도 향상(S)을 예측하는 데 사용된다.
이 법칙은 전체 시스템을 크게 가속화하려면 시스템 전체의 매우 큰 부분을 개선해야 한다는 주요 통찰을 제시한다.
반복문 성능을 측정하는 주요 척도는 요소당 사이클(CPE: Cycles Per Element)이다.
이는 전체 실행 시간을 처리된 요소 수로 나눈 값으로, 오버헤드 요소를 제외한 반복문의 핵심 성능을 반영한다.

# 3. 프로그램 예시

벡터 데이터 타입을 사용하여 여러 요소를 하나의 값으로 결합하는 `combine` 함수를 예시로 들어 최적화 과정을 설명한다.
이 함수는 `IDENT`(항등원)와 `OP`(연산) 매크로를 통해 합계나 곱셈 등 다양한 연산을 수행할 수 있도록 설정된다.

# 4. 반복문 비효율성 제거

반복문 내에서 변하지 않는 계산(loop-invariant computation)을 반복문 밖으로 이동시켜 오버헤드를 줄일 수 있다.
예를 들어, `vec_length` 함수 호출을 반복문 조건에서 한 번만 수행하도록 변경하거나, `strlen` 호출을 반복문 밖으로 옮겨 O(N²) 실행 시간을 O(N)으로 개선한 사례가 있다.

# 5. 프로시저 호출 감소

프로시저 호출은 오버헤드를 발생시키며 컴파일러 최적화를 방해할 수 있다.
`get_vec_element`와 같은 함수를 반복문 내에서 인라인화하거나, 포인터를 직접 사용하여 메모리 접근을 최적화함으로써 프로시저 호출 오버헤드를 줄일 수 있다.
