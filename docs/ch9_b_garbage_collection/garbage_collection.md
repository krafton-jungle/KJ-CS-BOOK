# 가비지 컬렉션

---

## 이 장에서 다루는 내용

이 장에서는 **메모리 관리 기법 중 하나인 가비지 컬렉션(Garbage Collection)**에 대해 다룬다.

- [간단한 설명] 사용하지 않는 메모리를 자동으로 회수하는 가비지 컬렉션의 개념과 방식에 대해 이해한다.
- [학습 이유] 명시적인 `free` 없이도 메모리 누수를 방지하는 방법을 익히고, 언어 수준에서의 자동 메모리 관리의 이점을 살펴본다.

---

## 주요 키워드

| 키워드        | 키워드    | 키워드      |
| ------------- | --------- | ----------- |
| 가비지 컬렉션 | 루트 집합 | 참조 그래프 |
| 마크-스윕     | 스택      | 힙          |
| 도달 가능성   | 세대별 GC | 할당자      |

---

## 1. 가비지 컬렉션이란?

**가비지 컬렉션(Garbage Collection)**은 프로그래머가 직접 `free`를 호출하지 않아도, **더 이상 사용되지 않는 메모리 블록을 자동으로 탐지하고 회수하는** 메모리 관리 기법이다.

이는 주로 자바, 파이썬, Go와 같은 언어에서 활용된다. 시스템 수준에서는 힙에 할당된 객체 중 프로그램 실행 중 **도달 불가능한 메모리 영역**을 정리하는 방식으로 작동한다.

---

## 2. 기본 주소 구조

가비지 컬렉션은 힙을 관리하므로, 메모리 주소와 포인터 추적이 중요하다.  
예를 들어 다음과 같은 포인터 구조를 생각해보자:

```
stack → object A → object B → object C
         ↑
       object D
```

여기서 스택에서 접근 가능한 객체 A를 통해 **B와 C는 도달 가능**하지만, D는 참조되지 않으므로 **가비지 대상**이 된다.

---

## 3. 대표적인 가비지 컬렉션 방식

### 마크-스윕(Mark-Sweep)

1. **Mark Phase (마킹 단계)**  
   루트 집합(스택, 전역 변수 등)에서 시작하여 도달 가능한 객체에 표시를 남긴다.

2. **Sweep Phase (청소 단계)**  
   힙 전체를 순회하며 마킹되지 않은 객체를 회수한다.

---

## 4. 예제 코드

다음은 C 언어에서는 명시적 메모리 해제를 사용해야 함을 보여주는 예시이다.

```c
char* p = malloc(100);
do_something(p);
free(p); // 명시적 해제 필요
```

---

## 마무리

가비지 컬렉션은 **메모리 안정성**, **디버깅 용이성**, **생산성 향상** 등 다양한 장점을 제공하지만, **예측 불가능한 실행 시간**이나 **일시적인 지연(Pause)** 문제도 존재한다.  
효율적인 시스템 개발을 위해 GC의 기본 원리를 이해하는 것이 중요하다.
