4장의 주요 내용은 다음과 같다.



첫째, \*\*4.1절 Y86-64 명령어 집합(ISA)\*\*에서는 학습용으로 단순화된 x86-64의 하위 집합인 Y86-64를 정의한다. 8개의 범용 64비트 레지스터, 64비트 PC, 상태 코드(정상·정지·주소 오류·명령어 오류) 등을 포함하며, 15개의 기본 명령어로 데이터 이동·산술·제어 흐름·스택 연산을 지원한다. 또한 간단한 C 함수(sum)를 예로 들어 x86-64와 Y86-64 코드가 어떻게 다른지 비교한다CSAPP\_2016.



둘째, 4.2절 HCL을 이용한 논리 회로 설계에서는 Hardware Control Language(HCL)를 사용해 비트 및 워드 단위 조합 회로를 기술하는 방법을 다룬다. 단일 비트 동등(equality) 회로와 멀티플렉서(multiplexor)를 HCL 식으로 표현하며, 워드 단위(예: 64비트) 회로를 설계하는 방식을 설명한다.



셋째, 4.3절 순차형(SEQ) Y86-64 구현에서는 한 클록 주기 안에 명령어 인출(fetch), 해독(decode), 실행(execute), 메모리(memory), 쓰기(back-write) 단계를 모두 처리하는 단일 사이클 프로세서를 설계한다. 각 단계에서 수행되는 연산과 데이터 흐름을 다이어그램으로 제시하며, 구현의 단순함과 함께 클록 속도가 느려지는 단점을 지적한다CSAPP\_2016.



넷째, 4.4절 파이프라이닝 일반 원리에서는 작업을 여러 단계로 분할해 명령어 처리량을 높이는 파이프라인 기법을 소개한다. 카페테리아·자동 세차 라인 비유를 통해 파이프라인의 병렬 처리 이점과 지연(latency)·처리량(throughput) 간의 트레이드오프를 설명한다CSAPP\_2016.



다섯째, 4.5절 파이프라인된(PIPE) Y86-64 구현에서는 SEQ+ 구조에서 파이프라인 레지스터를 추가해 Fetch→Decode→Execute→Memory→Write-Back 5단계 구조를 완성한다. 하자드(hazard) 해결을 위한 포워딩(bypassing) 기법, 분기 예측(branch prediction)과 레지스터 삽입 전략을 다루며, CPI 및 성능 향상 효과를 분석한다CSAPP\_2016.



이로써 4장은 ISA에서부터 HCL 기반 회로 설계, 단일 클록 처리, 파이프라인 일반 원리, 최종 파이프라인 구현까지 프로세서 아키텍처의 전 과정을 단계별로 제시한다.

